package main

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"github.com/cilium/ebpf" //nolint:goimports
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
	"log"
	"net"
	"os"
	"os/signal"
	"syscall" //nolint:goimports
)

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type event bpf enetmon.bpf.c -- -I./headers

type SkcState int

const (
	TcpInvalid SkcState = iota
	TcpEstablished
	TcpSynSent
	TcpSynRecv
	TcpFinWait1
	TcpFinWait2
	TcpTimeWait
	TcpClose
	TcpCloseWait
	TcpLastAck
	TcpListen
	TcpClosing
	TcpNewSynRecv
	TcpMaxStates
)

func (s SkcState) String() string {
	switch s {
	case TcpInvalid:
		return "TCP_INVALID"
	case TcpEstablished:
		return "TCP_ESTABLISHED"
	case TcpSynSent:
		return "TCP_SYN_SENT"
	case TcpSynRecv:
		return "TCP_SYN_RECV"
	case TcpFinWait1:
		return "TCP_FIN_WAIT1"
	case TcpFinWait2:
		return "TCP_FIN_WAIT2"
	case TcpTimeWait:
		return "TCP_TIME_WAIT"
	case TcpClose:
		return "TCP_CLOSE"
	case TcpCloseWait:
		return "TCP_CLOSE_WAIT"
	case TcpLastAck:
		return "TCP_LAST_ACK"
	case TcpListen:
		return "TCP_LISTEN"
	case TcpClosing:
		return "TCP_CLOSING"
	case TcpNewSynRecv:
		return "TCP_NEW_SYN_RECV"
	case TcpMaxStates:
		return "TCP_MAX_STATES"
	default:
		return "UNKNOWN"
	}
}

type FnType int

const (
	FnInvalid FnType = iota
	TcpCloseExit
	TcpConnectExit
	TcpV4ConnectExit
	TcpV6ConnectExit
	TcpDisconnectExit
	InetCskAcceptExit
	TcpShutdownExit
	TcpRecvmsgExit
	TcpSendmsgExit
	InetCskGetPortExit
	TcpAbortExit
	UdpInitSockExit
	UdpDestroySockExit
	UdpSendmsgExit
	UdpRecvmsgExit
)

func (f FnType) String() string {
	switch f {
	case FnInvalid:
		return "FnInvalid"
	case TcpCloseExit:
		return "tcp_close"
	case TcpConnectExit:
		return "tcp_connect"
	case TcpV4ConnectExit:
		return "tcp_v4_connect"
	case TcpV6ConnectExit:
		return "tcp_v6_connect"
	case TcpDisconnectExit:
		return "tcp_disconnect"
	case InetCskAcceptExit:
		return "inet_csk_accept"
	case TcpShutdownExit:
		return "tcp_shutdown"
	case TcpRecvmsgExit:
		return "tcp_recvmsg"
	case TcpSendmsgExit:
		return "tcp_sendmsg"
	case InetCskGetPortExit:
		return "inet_csk_get_port"
	case TcpAbortExit:
		return "tcp_abort"
	case UdpInitSockExit:
		return "udp_init_sock"
	case UdpDestroySockExit:
		return "udp_destroy_sock"
	case UdpSendmsgExit:
		return "udp_sendmsg"
	case UdpRecvmsgExit:
		return "udp_recvmsg"
	default:
		return "UNKNOWN"
	}
}

func (f FnType) IsTcp() bool {
	switch f {
	case TcpCloseExit, TcpConnectExit, TcpV4ConnectExit, TcpV6ConnectExit, TcpDisconnectExit, InetCskAcceptExit,
		TcpShutdownExit, TcpRecvmsgExit, TcpSendmsgExit, InetCskGetPortExit, TcpAbortExit:
		return true
	default:
		return false
	}
}

func (f FnType) IsUdp() bool {
	switch f {
	case UdpInitSockExit, UdpDestroySockExit, UdpSendmsgExit, UdpRecvmsgExit:
		return true
	default:
		return false
	}
}

func intToIP(ipNum uint32) net.IP {
	ip := make(net.IP, net.IPv4len)
	binary.NativeEndian.PutUint32(ip, ipNum)
	return ip
}

func getIPAddr(event bpfEvent) (srcIPAddr, dstIPAddr net.IP) {
	if event.Family == syscall.AF_INET {
		srcIPAddr = intToIP(event.Saddr)
		dstIPAddr = intToIP(event.Daddr)
	} else {
		srcIPAddr = event.V6Saddr.In6U.U6Addr8[:]
		dstIPAddr = event.V6Daddr.In6U.U6Addr8[:]
	}
	return srcIPAddr, dstIPAddr
}

func errnoToString(errno int32) string {
	if errno == 0 {
		return ""
	} else {
		return syscall.Errno(errno).Error()
	}
}

// customize your own log format
func printEventLog(event bpfEvent) {
	srcIPAddr, dstIPAddr := getIPAddr(event)
	fnType := FnType(event.FnType)
	if fnType.IsTcp() {
		log.Printf("TCP: %s %s err=\"%s\" %s src=%s:%d dst=%s:%d rcv/snd(%d/%d)",
			event.Comm,
			fnType,
			errnoToString(event.SkErr),
			SkcState(event.State),
			srcIPAddr,
			event.Sport,
			dstIPAddr,
			event.Dport,
			event.SkRcvbuf,
			event.SkSndbuf,
		)
	}
	if fnType.IsUdp() {
		log.Printf("UDP: %s %s err=\"%s\" src=%s:%d dst=%s:%d rcv/snd(%d/%d)",
			event.Comm,
			fnType,
			errnoToString(event.SkErr),
			srcIPAddr,
			event.Sport,
			dstIPAddr,
			event.Dport,
			event.SkRcvbuf,
			event.SkSndbuf,
		)
	}
}

func processEvents(ctx context.Context, rd *ringbuf.Reader) error {
	// bpfEvent is generated by bpf2go.,
	var event bpfEvent
	for {
		select {
		case <-ctx.Done():
			// If the context is cancelled, return from the function,
			// which will cause the goroutine to exit.
			return nil
		default:
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, ringbuf.ErrClosed) {
					log.Println("received signal, exiting..")
					return nil
				}
				log.Printf("reading from reader: %s", err)
				continue
			}
			// Parse the ringbuf event entry into a bpfEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.NativeEndian, &event); err != nil {
				log.Printf("parsing ringbuf event: %s", err)
				continue
			}

			printEventLog(event)
		}
	}
}

func eventLoop(ctx context.Context, objs bpfObjects, program *ebpf.Program, eventMap *ebpf.Map) error {
	defer func() {
		_ = objs.Close()
	}()

	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		return fmt.Errorf("removing memlock rlimit: %v", err)
	}

	lnk, err := link.AttachTracing(link.TracingOptions{Program: program})
	if err != nil {
		return fmt.Errorf("attaching tracing link: %v", err)
	}
	defer func() { _ = lnk.Close() }()

	rd, err := ringbuf.NewReader(eventMap)
	if err != nil {
		return fmt.Errorf("creating ringbuf reader: %v", err)
	}
	defer func() { _ = rd.Close() }()

	if err := processEvents(ctx, rd); err != nil {
		return err
	}

	return nil
}

func tcpClose(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpCloseExit, objs.bpfMaps.TcpCloseEvent)
}

func tcpConnect(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpConnectExit, objs.bpfMaps.TcpConnectEvent)
}

//nolint:unused
func tcpTcpV4Connect(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpV4ConnectExit, objs.bpfMaps.TcpV4ConnectEvent)
}

//nolint:unused
func tcpTcpV6Connect(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpV6ConnectExit, objs.bpfMaps.TcpV6ConnectEvent)
}

func tcpTcpDisconnect(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpDisconnectExit, objs.bpfMaps.TcpDisconnectEvent)
}

func inetCaskAccept(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.InetCskAcceptExit, objs.bpfMaps.InetCskAcceptEvent)
}

func tcpShutdown(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpShutdownExit, objs.bpfMaps.TcpShutdownEvent)
}

func tcpRecvmsg(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpRecvmsgExit, objs.bpfMaps.TcpRecvmsgEvent)
}

func tcpSendmsg(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpSendmsgExit, objs.bpfMaps.TcpSendmsgEvent)
}

func inetCskGetPort(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.InetCskGetPortExit, objs.bpfMaps.InetCskGetPortEvent)
}

func tcpAbort(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.TcpAbortExit, objs.bpfMaps.TcpAbortEvent)
}

func udpInitSock(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.UdpInitSockExit, objs.bpfMaps.UdpInitSockEvent)
}

func udpDestroySock(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.UdpDestroySockExit, objs.bpfMaps.UdpDestroySockEvent)
}

func udpSendmsg(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.UdpSendmsgExit, objs.bpfMaps.UdpSendmsgEvent)
}

func udpRecvmsg(ctx context.Context, objs bpfObjects) error {
	return eventLoop(ctx, objs, objs.bpfPrograms.UdpRecvmsgExit, objs.bpfMaps.UdpRecvmsgEvent)
}

func run(ctx context.Context, cancel context.CancelFunc, fn func(context.Context, bpfObjects) error, objs bpfObjects) {
	if err := fn(ctx, objs); err != nil {
		log.Println(err)
		cancel()
	}
}

var (
	version       string //no:lint:gochecknoglobals
	versionOption = flag.Bool("v", false, "version: "+version)
)

func main() {
	flag.Parse()
	if *versionOption {
		fmt.Printf("version: %s\n", version)
		os.Exit(0)
	}

	ctx, cancel := context.WithCancel(context.Background())

	// Handle Ctrl+C.
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT)

	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		log.Printf("loading objects: %v", err)
		return
	}

	go run(ctx, cancel, tcpClose, objs)
	go run(ctx, cancel, tcpConnect, objs)
	// go run(ctx, cancel, tcpTcpV4Connect, objs)
	// go run(ctx, cancel, tcpTcpV6Connect, objs)
	go run(ctx, cancel, tcpTcpDisconnect, objs)
	go run(ctx, cancel, inetCaskAccept, objs)
	go run(ctx, cancel, tcpShutdown, objs)
	go run(ctx, cancel, tcpRecvmsg, objs)
	go run(ctx, cancel, tcpSendmsg, objs)
	go run(ctx, cancel, inetCskGetPort, objs)
	go run(ctx, cancel, tcpAbort, objs)
	go run(ctx, cancel, udpInitSock, objs)
	go run(ctx, cancel, udpDestroySock, objs)
	go run(ctx, cancel, udpSendmsg, objs)
	go run(ctx, cancel, udpRecvmsg, objs)

	if <-sigs; true {
		_, _ = fmt.Fprintf(os.Stderr, "received SIGINT, cancelling\n")
		cancel()
	}
}
